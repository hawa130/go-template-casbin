package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"

	"github.com/hawa130/computility-cloud/graph/model"
	"github.com/hawa130/computility-cloud/graph/reqerr"
	"github.com/hawa130/computility-cloud/graph/utils"
	"github.com/hawa130/computility-cloud/internal/auth"
	"github.com/hawa130/computility-cloud/internal/perm"
)

// AddPolicy is the resolver for the addPolicy field.
func (r *mutationResolver) AddPolicy(ctx context.Context, input model.CRequestInput) (*model.CPolicyResult, error) {
	allow, err := auth.IsAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if !allow {
		return nil, reqerr.ErrForbidden
	}
	ok, err := perm.Enforcer().AddPolicy(utils.PolicyToAnyArr(&input)...)
	if err != nil {
		return nil, err
	}
	return utils.ToResult(&input, ok), nil
}

// AddPolicies is the resolver for the addPolicies field.
func (r *mutationResolver) AddPolicies(ctx context.Context, input []*model.CRequestInput) (*model.BatchCPolicy, error) {
	allow, err := auth.IsAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if !allow {
		return nil, reqerr.ErrForbidden
	}
	ok, err := perm.Enforcer().AddPolicies(utils.PoliciesToStringArr(input))
	if err != nil {
		return nil, err
	}
	return utils.ToBatchResult(input, ok), nil
}

// AddNamedPolicy is the resolver for the addNamedPolicy field.
func (r *mutationResolver) AddNamedPolicy(ctx context.Context, pType string, input model.CRequestInput) (*model.CPolicyResult, error) {
	allow, err := auth.IsAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if !allow {
		return nil, reqerr.ErrForbidden
	}
	ok, err := perm.Enforcer().AddNamedPolicy(pType, utils.PolicyToAnyArr(&input)...)
	if err != nil {
		return nil, err
	}
	return utils.ToResult(&input, ok), nil
}

// AddNamedPolicies is the resolver for the addNamedPolicies field.
func (r *mutationResolver) AddNamedPolicies(ctx context.Context, pType string, input []*model.CRequestInput) (*model.BatchCPolicy, error) {
	allow, err := auth.IsAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if !allow {
		return nil, reqerr.ErrForbidden
	}
	ok, err := perm.Enforcer().AddNamedPoliciesEx(pType, utils.PoliciesToStringArr(input))
	if err != nil {
		return nil, err
	}
	return utils.ToBatchResult(input, ok), nil
}

// DeletePolicy is the resolver for the deletePolicy field.
func (r *mutationResolver) DeletePolicy(ctx context.Context, input model.CRequestInput) (*model.CPolicyResult, error) {
	allow, err := auth.IsAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if !allow {
		return nil, reqerr.ErrForbidden
	}
	ok, err := perm.Enforcer().RemovePolicy(utils.PolicyToAnyArr(&input)...)
	if err != nil {
		return nil, err
	}
	return utils.ToResult(&input, ok), nil
}

// UpdatePolicy is the resolver for the updatePolicy field.
func (r *mutationResolver) UpdatePolicy(ctx context.Context, new model.CRequestInput, old model.CRequestInput) (*model.UpdateCPolicy, error) {
	allow, err := auth.IsAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if !allow {
		return nil, reqerr.ErrForbidden
	}
	res, err := perm.Enforcer().UpdatePolicy(utils.PolicyToStringArr(&old), utils.PolicyToStringArr(&new))
	if err != nil {
		return nil, err
	}
	return utils.ToUpdateResult(&new, &old, res), nil
}

// AddGroupingPolicy is the resolver for the addGroupingPolicy field.
func (r *mutationResolver) AddGroupingPolicy(ctx context.Context, input model.CGroupInput) (*model.CGroupResult, error) {
	allow, err := auth.IsAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if !allow {
		return nil, reqerr.ErrForbidden
	}
	res, err := perm.Enforcer().AddGroupingPolicy(utils.GroupToAnyArr(&input)...)
	if err != nil {
		return nil, err
	}
	return utils.ToGroupResult(&input, res), nil
}

// AddGroupingPolicies is the resolver for the addGroupingPolicies field.
func (r *mutationResolver) AddGroupingPolicies(ctx context.Context, input []*model.CGroupInput) (*model.BatchCGroup, error) {
	allow, err := auth.IsAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if !allow {
		return nil, reqerr.ErrForbidden
	}
	res, err := perm.Enforcer().AddGroupingPoliciesEx(utils.GroupsToStringArr(input))
	if err != nil {
		return nil, err
	}
	return utils.ToBatchGroupResult(input, res), nil
}

// AddNamedGroupingPolicy is the resolver for the addNamedGroupingPolicy field.
func (r *mutationResolver) AddNamedGroupingPolicy(ctx context.Context, pType string, input model.CGroupInput) (*model.CGroupResult, error) {
	allow, err := auth.IsAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if !allow {
		return nil, reqerr.ErrForbidden
	}
	res, err := perm.Enforcer().AddNamedGroupingPolicy(pType, utils.GroupToAnyArr(&input)...)
	if err != nil {
		return nil, err
	}
	return utils.ToGroupResult(&input, res), nil
}

// AddNamedGroupingPolicies is the resolver for the addNamedGroupingPolicies field.
func (r *mutationResolver) AddNamedGroupingPolicies(ctx context.Context, pType string, input []*model.CGroupInput) (*model.BatchCGroup, error) {
	allow, err := auth.IsAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if !allow {
		return nil, reqerr.ErrForbidden
	}
	res, err := perm.Enforcer().AddNamedGroupingPolicies(pType, utils.GroupsToStringArr(input))
	if err != nil {
		return nil, err
	}
	return utils.ToBatchGroupResult(input, res), nil
}

// DeleteGroupingPolicy is the resolver for the deleteGroupingPolicy field.
func (r *mutationResolver) DeleteGroupingPolicy(ctx context.Context, input model.CGroupInput) (*model.CGroupResult, error) {
	allow, err := auth.IsAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if !allow {
		return nil, reqerr.ErrForbidden
	}
	res, err := perm.Enforcer().RemoveGroupingPolicy(utils.GroupToAnyArr(&input)...)
	if err != nil {
		return nil, err
	}
	return utils.ToGroupResult(&input, res), nil
}

// UpdateGroupingPolicy is the resolver for the updateGroupingPolicy field.
func (r *mutationResolver) UpdateGroupingPolicy(ctx context.Context, new model.CGroupInput, old model.CGroupInput) (*model.UpdateCGroup, error) {
	allow, err := auth.IsAdmin(ctx)
	if err != nil {
		return nil, err
	}
	if !allow {
		return nil, reqerr.ErrForbidden
	}
	res, err := perm.Enforcer().UpdateGroupingPolicy(utils.GroupToStringArr(&old), utils.GroupToStringArr(&new))
	if err != nil {
		return nil, err
	}
	return utils.ToGroupUpdateResult(&new, &old, res), nil
}

// Enforce is the resolver for the enforce field.
func (r *queryResolver) Enforce(ctx context.Context, input model.CRequestInput) (*model.CPolicyResult, error) {
	res, err := perm.Enforcer().Enforce(utils.PolicyToAnyArr(&input)...)
	if err != nil {
		return nil, err
	}
	return utils.ToResult(&input, res), nil
}

// Policy is the resolver for the policy field.
func (r *queryResolver) Policy(ctx context.Context, name *string) ([]*model.CPolicy, error) {
	var policies [][]string
	var err error
	if name != nil {
		policies, err = perm.Enforcer().GetNamedPolicy(*name)
	} else {
		policies, err = perm.Enforcer().GetPolicy()
	}

	result := make([]*model.CPolicy, 0)
	for _, policy := range policies {
		result = append(result, utils.StringArrToPolicy(policy))
	}
	return result, err
}

// GroupingPolicy is the resolver for the groupingPolicy field.
func (r *queryResolver) GroupingPolicy(ctx context.Context, name *string) ([]*model.CGroup, error) {
	var groups [][]string
	var err error
	if name != nil {
		groups, err = perm.Enforcer().GetNamedGroupingPolicy(*name)
	} else {
		groups, err = perm.Enforcer().GetGroupingPolicy()
	}

	result := make([]*model.CGroup, 0)
	for _, group := range groups {
		result = append(result, utils.StringArrToGroup(group))
	}
	return result, err
}
